"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zen-observable-ts";
exports.ids = ["vendor-chunks/zen-observable-ts"];
exports.modules = {

/***/ "(ssr)/./node_modules/zen-observable-ts/module.js":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable)\n/* harmony export */ });\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\n// === Symbol Support ===\nvar hasSymbols = function() {\n    return typeof Symbol === \"function\";\n};\nvar hasSymbol = function(name) {\n    return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n};\nif (hasSymbols() && !hasSymbol(\"observable\")) {\n    Symbol.observable = Symbol(\"observable\");\n}\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\nfunction getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n}\nfunction getSpecies(obj) {\n    var ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(e) {\n    if (hostReportError.log) {\n        hostReportError.log(e);\n    } else {\n        setTimeout(function() {\n            throw e;\n        });\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(function() {\n        try {\n            fn();\n        } catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    var cleanup = subscription._cleanup;\n    if (cleanup === undefined) return;\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        } else {\n            var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    var queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for(var i = 0; i < queue.length; ++i){\n        notifySubscription(subscription, queue[i].type, queue[i].value);\n        if (subscription._state === \"closed\") break;\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    var observer = subscription._observer;\n    try {\n        var m = getMethod(observer, type);\n        switch(type){\n            case \"next\":\n                if (m) m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m) m.call(observer, value);\n                else throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m) m.call(observer);\n                break;\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") cleanupSubscription(subscription);\n    else if (subscription._state === \"running\") subscription._state = \"ready\";\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") return;\n    if (subscription._state === \"buffering\") {\n        subscription._queue.push({\n            type: type,\n            value: value\n        });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [\n            {\n                type: type,\n                value: value\n            }\n        ];\n        enqueue(function() {\n            return flushSubscription(subscription);\n        });\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nvar Subscription = /*#__PURE__*/ function() {\n    function Subscription(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        var subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        } catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") this._state = \"ready\";\n    }\n    var _proto = Subscription.prototype;\n    _proto.unsubscribe = function unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    };\n    _createClass(Subscription, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._state === \"closed\";\n            }\n        }\n    ]);\n    return Subscription;\n}();\nvar SubscriptionObserver = /*#__PURE__*/ function() {\n    function SubscriptionObserver(subscription) {\n        this._subscription = subscription;\n    }\n    var _proto2 = SubscriptionObserver.prototype;\n    _proto2.next = function next(value) {\n        onNotify(this._subscription, \"next\", value);\n    };\n    _proto2.error = function error(value) {\n        onNotify(this._subscription, \"error\", value);\n    };\n    _proto2.complete = function complete() {\n        onNotify(this._subscription, \"complete\");\n    };\n    _createClass(SubscriptionObserver, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._subscription._state === \"closed\";\n            }\n        }\n    ]);\n    return SubscriptionObserver;\n}();\nvar Observable = /*#__PURE__*/ function() {\n    function Observable(subscriber) {\n        if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\");\n        if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n        this._subscriber = subscriber;\n    }\n    var _proto3 = Observable.prototype;\n    _proto3.subscribe = function subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n            observer = {\n                next: observer,\n                error: arguments[1],\n                complete: arguments[2]\n            };\n        }\n        return new Subscription(observer, this._subscriber);\n    };\n    _proto3.forEach = function forEach(fn) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve();\n            }\n            var subscription = _this.subscribe({\n                next: function(value) {\n                    try {\n                        fn(value, done);\n                    } catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve\n            });\n        });\n    };\n    _proto3.map = function map(fn) {\n        var _this2 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this2.subscribe({\n                next: function(value) {\n                    try {\n                        value = fn(value);\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.filter = function filter(fn) {\n        var _this3 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this3.subscribe({\n                next: function(value) {\n                    try {\n                        if (!fn(value)) return;\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.reduce = function reduce(fn) {\n        var _this4 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        var hasSeed = arguments.length > 1;\n        var hasValue = false;\n        var seed = arguments[1];\n        var acc = seed;\n        return new C(function(observer) {\n            return _this4.subscribe({\n                next: function(value) {\n                    var first = !hasValue;\n                    hasValue = true;\n                    if (!first || hasSeed) {\n                        try {\n                            acc = fn(acc, value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    } else {\n                        acc = value;\n                    }\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    if (!hasValue && !hasSeed) return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                    observer.next(acc);\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.concat = function concat() {\n        var _this5 = this;\n        for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n            sources[_key] = arguments[_key];\n        }\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscription;\n            var index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next: function(v) {\n                        observer.next(v);\n                    },\n                    error: function(e) {\n                        observer.error(e);\n                    },\n                    complete: function() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        } else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    }\n                });\n            }\n            startNext(_this5);\n            return function() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    };\n    _proto3.flatMap = function flatMap(fn) {\n        var _this6 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscriptions = [];\n            var outer = _this6.subscribe({\n                next: function(value) {\n                    if (fn) {\n                        try {\n                            value = fn(value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    var inner = C.from(value).subscribe({\n                        next: function(value) {\n                            observer.next(value);\n                        },\n                        error: function(e) {\n                            observer.error(e);\n                        },\n                        complete: function() {\n                            var i = subscriptions.indexOf(inner);\n                            if (i >= 0) subscriptions.splice(i, 1);\n                            completeIfDone();\n                        }\n                    });\n                    subscriptions.push(inner);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    completeIfDone();\n                }\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) observer.complete();\n            }\n            return function() {\n                subscriptions.forEach(function(s) {\n                    return s.unsubscribe();\n                });\n                outer.unsubscribe();\n            };\n        });\n    };\n    _proto3[SymbolObservable] = function() {\n        return this;\n    };\n    Observable.from = function from(x) {\n        var C = typeof this === \"function\" ? this : Observable;\n        if (x == null) throw new TypeError(x + \" is not an object\");\n        var method = getMethod(x, SymbolObservable);\n        if (method) {\n            var observable = method.call(x);\n            if (Object(observable) !== observable) throw new TypeError(observable + \" is not an object\");\n            if (isObservable(observable) && observable.constructor === C) return observable;\n            return new C(function(observer) {\n                return observable.subscribe(observer);\n            });\n        }\n        if (hasSymbol(\"iterator\")) {\n            method = getMethod(x, SymbolIterator);\n            if (method) {\n                return new C(function(observer) {\n                    enqueue(function() {\n                        if (observer.closed) return;\n                        for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){\n                            var item = _step.value;\n                            observer.next(item);\n                            if (observer.closed) return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(function(observer) {\n                enqueue(function() {\n                    if (observer.closed) return;\n                    for(var i = 0; i < x.length; ++i){\n                        observer.next(x[i]);\n                        if (observer.closed) return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    };\n    Observable.of = function of() {\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        var C = typeof this === \"function\" ? this : Observable;\n        return new C(function(observer) {\n            enqueue(function() {\n                if (observer.closed) return;\n                for(var i = 0; i < items.length; ++i){\n                    observer.next(items[i]);\n                    if (observer.closed) return;\n                }\n                observer.complete();\n            });\n        });\n    };\n    _createClass(Observable, null, [\n        {\n            key: SymbolSpecies,\n            get: function() {\n                return this;\n            }\n        }\n    ]);\n    return Observable;\n}();\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError: hostReportError\n        },\n        configurable: true\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvbW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxnQ0FBZ0NDLENBQUMsRUFBRUMsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT0MsV0FBVyxlQUFlSCxDQUFDLENBQUNHLE9BQU9DLFFBQVEsQ0FBQyxJQUFJSixDQUFDLENBQUMsYUFBYTtJQUFFLElBQUlFLElBQUksT0FBTyxDQUFDQSxLQUFLQSxHQUFHRyxJQUFJLENBQUNMLEVBQUMsRUFBR00sSUFBSSxDQUFDQyxJQUFJLENBQUNMO0lBQUssSUFBSU0sTUFBTUMsT0FBTyxDQUFDVCxNQUFPRSxDQUFBQSxLQUFLUSw0QkFBNEJWLEVBQUMsS0FBTUMsa0JBQWtCRCxLQUFLLE9BQU9BLEVBQUVXLE1BQU0sS0FBSyxVQUFVO1FBQUUsSUFBSVQsSUFBSUYsSUFBSUU7UUFBSSxJQUFJVSxJQUFJO1FBQUcsT0FBTztZQUFjLElBQUlBLEtBQUtaLEVBQUVXLE1BQU0sRUFBRSxPQUFPO2dCQUFFRSxNQUFNO1lBQUs7WUFBRyxPQUFPO2dCQUFFQSxNQUFNO2dCQUFPQyxPQUFPZCxDQUFDLENBQUNZLElBQUk7WUFBQztRQUFHO0lBQUc7SUFBRSxNQUFNLElBQUlHLFVBQVU7QUFBMEk7QUFFM2xCLFNBQVNMLDRCQUE0QlYsQ0FBQyxFQUFFZ0IsTUFBTTtJQUFJLElBQUksQ0FBQ2hCLEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPaUIsa0JBQWtCakIsR0FBR2dCO0lBQVMsSUFBSUUsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNoQixJQUFJLENBQUNMLEdBQUdzQixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUosTUFBTSxZQUFZbEIsRUFBRXVCLFdBQVcsRUFBRUwsSUFBSWxCLEVBQUV1QixXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJTixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPVixNQUFNaUIsSUFB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T0FBT2tCLGNBQWMsQ0FBQ21CLFlBQVlyRCxPQUFPLGVBQWU7UUFDdERXLE9BQU87WUFDTDhILFFBQVEzRjtZQUNSVSxpQkFBaUJBO1FBQ25CO1FBQ0F4QixjQUFjO0lBQ2hCO0FBQ0Y7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sb2ctcXVlcnktd2ViLy4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL21vZHVsZS5qcz9mNzlmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vID09PSBTeW1ib2wgU3VwcG9ydCA9PT1cbnZhciBoYXNTeW1ib2xzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBoYXNTeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaGFzU3ltYm9scygpICYmIEJvb2xlYW4oU3ltYm9sW25hbWVdKTtcbn07XG5cbnZhciBnZXRTeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaGFzU3ltYm9sKG5hbWUpID8gU3ltYm9sW25hbWVdIDogJ0BAJyArIG5hbWU7XG59O1xuXG5pZiAoaGFzU3ltYm9scygpICYmICFoYXNTeW1ib2woJ29ic2VydmFibGUnKSkge1xuICBTeW1ib2wub2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xufVxuXG52YXIgU3ltYm9sSXRlcmF0b3IgPSBnZXRTeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xudmFyIFN5bWJvbFNwZWNpZXMgPSBnZXRTeW1ib2woJ3NwZWNpZXMnKTsgLy8gPT09IEFic3RyYWN0IE9wZXJhdGlvbnMgPT09XG5cbmZ1bmN0aW9uIGdldE1ldGhvZChvYmosIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BlY2llcyhvYmopIHtcbiAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgaWYgKGN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IgPSBjdG9yW1N5bWJvbFNwZWNpZXNdO1xuXG4gICAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICAgIGN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN0b3IgIT09IHVuZGVmaW5lZCA/IGN0b3IgOiBPYnNlcnZhYmxlO1xufVxuXG5mdW5jdGlvbiBpc09ic2VydmFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE9ic2VydmFibGU7IC8vIFNQRUM6IEJyYW5kIGNoZWNrXG59XG5cbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlKSB7XG4gIGlmIChob3N0UmVwb3J0RXJyb3IubG9nKSB7XG4gICAgaG9zdFJlcG9ydEVycm9yLmxvZyhlKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZShmbikge1xuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2NsZWFudXA7XG4gIGlmIChjbGVhbnVwID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgc3Vic2NyaXB0aW9uLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXG4gIGlmICghY2xlYW51cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1bnN1YnNjcmliZSA9IGdldE1ldGhvZChjbGVhbnVwLCAndW5zdWJzY3JpYmUnKTtcblxuICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlLmNhbGwoY2xlYW51cCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaG9zdFJlcG9ydEVycm9yKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICBzdWJzY3JpcHRpb24uX29ic2VydmVyID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ2Nsb3NlZCc7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgcXVldWUgPSBzdWJzY3JpcHRpb24uX3F1ZXVlO1xuXG4gIGlmICghcXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3JlYWR5JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgcXVldWVbaV0udHlwZSwgcXVldWVbaV0udmFsdWUpO1xuICAgIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdydW5uaW5nJztcbiAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vYnNlcnZlcjtcblxuICB0cnkge1xuICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLCB0eXBlKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgIGlmIChtKSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO2Vsc2UgdGhyb3cgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGlmIChtKSBtLmNhbGwob2JzZXJ2ZXIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cblxuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtlbHNlIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAncnVubmluZycpIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xufVxuXG5mdW5jdGlvbiBvbk5vdGlmeShzdWJzY3JpcHRpb24sIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgcmV0dXJuO1xuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnYnVmZmVyaW5nJykge1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUucHVzaCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSAhPT0gJ3JlYWR5Jykge1xuICAgIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnYnVmZmVyaW5nJztcbiAgICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gW3tcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9XTtcbiAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbHVzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vdGlmeVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIHR5cGUsIHZhbHVlKTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICAgIC8vIEFTU0VSVDogb2JzZXJ2ZXIgaXMgYW4gb2JqZWN0XG4gICAgLy8gQVNTRVJUOiBzdWJzY3JpYmVyIGlzIGNhbGxhYmxlXG4gICAgdGhpcy5fY2xlYW51cCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXRlID0gJ2luaXRpYWxpemluZyc7XG4gICAgdmFyIHN1YnNjcmlwdGlvbk9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NsZWFudXAgPSBzdWJzY3JpYmVyLmNhbGwodW5kZWZpbmVkLCBzdWJzY3JpcHRpb25PYnNlcnZlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSAnaW5pdGlhbGl6aW5nJykgdGhpcy5fc3RhdGUgPSAncmVhZHknO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN1YnNjcmlwdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uLCBbe1xuICAgIGtleTogXCJjbG9zZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gJ2Nsb3NlZCc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uT2JzZXJ2ZXIoc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBTdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5uZXh0ID0gZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgIG9uTm90aWZ5KHRoaXMuX3N1YnNjcmlwdGlvbiwgJ25leHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvMi5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnZXJyb3InLCB2YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgIG9uTm90aWZ5KHRoaXMuX3N1YnNjcmlwdGlvbiwgJ2NvbXBsZXRlJyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnNjcmlwdGlvbk9ic2VydmVyLCBbe1xuICAgIGtleTogXCJjbG9zZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uT2JzZXJ2ZXI7XG59KCk7XG5cbnZhciBPYnNlcnZhYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9ic2VydmFibGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbicpO1xuICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JzZXJ2YWJsZSBpbml0aWFsaXplciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gT2JzZXJ2YWJsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0JyB8fCBvYnNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgIG5leHQ6IG9ic2VydmVyLFxuICAgICAgICBlcnJvcjogYXJndW1lbnRzWzFdLFxuICAgICAgICBjb21wbGV0ZTogYXJndW1lbnRzWzJdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9zdWJzY3JpYmVyKTtcbiAgfTtcblxuICBfcHJvdG8zLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKHZhbHVlLCBkb25lKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLm1hcCA9IGZ1bmN0aW9uIG1hcChmbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzMi5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihmbikge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzMy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFmbih2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMucmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGZuKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICB2YXIgaGFzU2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBzZWVkID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBhY2MgPSBzZWVkO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBfdGhpczQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGZpcnN0ID0gIWhhc1ZhbHVlO1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghZmlyc3QgfHwgaGFzU2VlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYWNjID0gZm4oYWNjLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1ZhbHVlICYmICFoYXNTZWVkKSByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IobmV3IFR5cGVFcnJvcignQ2Fubm90IHJlZHVjZSBhbiBlbXB0eSBzZXF1ZW5jZScpKTtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGFjYyk7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydE5leHQobmV4dCkge1xuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXh0LnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnROZXh0KEMuZnJvbShzb3VyY2VzW2luZGV4KytdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc3RhcnROZXh0KF90aGlzNSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuZmxhdE1hcCA9IGZ1bmN0aW9uIGZsYXRNYXAoZm4pIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XG5cbiAgICAgIHZhciBvdXRlciA9IF90aGlzNi5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlubmVyID0gQy5mcm9tKHZhbHVlKS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihpbm5lcik7XG4gICAgICAgICAgICAgIGlmIChpID49IDApIHN1YnNjcmlwdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICBjb21wbGV0ZUlmRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChpbm5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBjb21wbGV0ZUlmRG9uZSgpIHtcbiAgICAgICAgaWYgKG91dGVyLmNsb3NlZCAmJiBzdWJzY3JpcHRpb25zLmxlbmd0aCA9PT0gMCkgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dGVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzNbU3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5mcm9tID0gZnVuY3Rpb24gZnJvbSh4KSB7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBPYnNlcnZhYmxlO1xuICAgIGlmICh4ID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoeCwgU3ltYm9sT2JzZXJ2YWJsZSk7XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG1ldGhvZC5jYWxsKHgpO1xuICAgICAgaWYgKE9iamVjdChvYnNlcnZhYmxlKSAhPT0gb2JzZXJ2YWJsZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihvYnNlcnZhYmxlICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICBpZiAoaXNPYnNlcnZhYmxlKG9ic2VydmFibGUpICYmIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMpIHJldHVybiBvYnNlcnZhYmxlO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1N5bWJvbCgnaXRlcmF0b3InKSkge1xuICAgICAgbWV0aG9kID0gZ2V0TWV0aG9kKHgsIFN5bWJvbEl0ZXJhdG9yKTtcblxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobWV0aG9kLmNhbGwoeCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW0pO1xuICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh4W2ldKTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgbm90IG9ic2VydmFibGUnKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLm9mID0gZnVuY3Rpb24gb2YoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tpXSk7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlLCBudWxsLCBbe1xuICAgIGtleTogU3ltYm9sU3BlY2llcyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlO1xufSgpO1xuXG5pZiAoaGFzU3ltYm9scygpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlLCBTeW1ib2woJ2V4dGVuc2lvbnMnKSwge1xuICAgIHZhbHVlOiB7XG4gICAgICBzeW1ib2w6IFN5bWJvbE9ic2VydmFibGUsXG4gICAgICBob3N0UmVwb3J0RXJyb3I6IGhvc3RSZXBvcnRFcnJvclxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBPYnNlcnZhYmxlIH07XG4iXSwibmFtZXMiOlsiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsIm8iLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjYWxsIiwibmV4dCIsImJpbmQiLCJBcnJheSIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJsZW5ndGgiLCJpIiwiZG9uZSIsInZhbHVlIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiYXJyIiwibGVuIiwiYXJyMiIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImhhc1N5bWJvbHMiLCJoYXNTeW1ib2wiLCJCb29sZWFuIiwiZ2V0U3ltYm9sIiwib2JzZXJ2YWJsZSIsIlN5bWJvbEl0ZXJhdG9yIiwiU3ltYm9sT2JzZXJ2YWJsZSIsIlN5bWJvbFNwZWNpZXMiLCJnZXRNZXRob2QiLCJvYmoiLCJ1bmRlZmluZWQiLCJnZXRTcGVjaWVzIiwiY3RvciIsIk9ic2VydmFibGUiLCJpc09ic2VydmFibGUiLCJ4IiwiaG9zdFJlcG9ydEVycm9yIiwiZSIsImxvZyIsInNldFRpbWVvdXQiLCJlbnF1ZXVlIiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjbGVhbnVwU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiY2xlYW51cCIsIl9jbGVhbnVwIiwidW5zdWJzY3JpYmUiLCJjbG9zZVN1YnNjcmlwdGlvbiIsIl9vYnNlcnZlciIsIl9xdWV1ZSIsIl9zdGF0ZSIsImZsdXNoU3Vic2NyaXB0aW9uIiwicXVldWUiLCJub3RpZnlTdWJzY3JpcHRpb24iLCJ0eXBlIiwib2JzZXJ2ZXIiLCJtIiwib25Ob3RpZnkiLCJwdXNoIiwiU3Vic2NyaXB0aW9uIiwic3Vic2NyaWJlciIsInN1YnNjcmlwdGlvbk9ic2VydmVyIiwiU3Vic2NyaXB0aW9uT2JzZXJ2ZXIiLCJlcnJvciIsIl9wcm90byIsImdldCIsIl9zdWJzY3JpcHRpb24iLCJfcHJvdG8yIiwiY29tcGxldGUiLCJfc3Vic2NyaWJlciIsIl9wcm90bzMiLCJzdWJzY3JpYmUiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX3RoaXMiLCJyZWplY3QiLCJtYXAiLCJfdGhpczIiLCJDIiwiZmlsdGVyIiwiX3RoaXMzIiwicmVkdWNlIiwiX3RoaXM0IiwiaGFzU2VlZCIsImhhc1ZhbHVlIiwic2VlZCIsImFjYyIsImZpcnN0IiwiY29uY2F0IiwiX3RoaXM1IiwiX2xlbiIsInNvdXJjZXMiLCJfa2V5IiwiaW5kZXgiLCJzdGFydE5leHQiLCJ2IiwiZmxhdE1hcCIsIl90aGlzNiIsInN1YnNjcmlwdGlvbnMiLCJvdXRlciIsImlubmVyIiwiaW5kZXhPZiIsInNwbGljZSIsImNvbXBsZXRlSWZEb25lIiwiY2xvc2VkIiwicyIsIm1ldGhvZCIsIl9pdGVyYXRvciIsIl9zdGVwIiwiaXRlbSIsIm9mIiwiX2xlbjIiLCJpdGVtcyIsIl9rZXkyIiwic3ltYm9sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zen-observable-ts/module.js\n");

/***/ })

};
;